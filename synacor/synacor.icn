link scan
global Mem
global Regs
record Reg(v)
global Stack
global SP
global IP
global CC
global opFuncs


procedure main(args)

    Init()

    inf := open(args[1],"ru")
    rp := 1
    while data := reads(data,1024) do {
        data ? {
            while not pos(0) do
                Mem[rp] := unpack()
                rp +:= 1
        }
    }
    close(inf)

    repeat {
        case Mem[IP+:=1] of {
            0 : { # Halt
                break
            }
            1 : { # set: 1 a b set register <a> to the value of <b>
                a := getVal(IP+:=1)
                b := getVal(IP+:=1)
                if type(a) ~== "Reg" then stop("Invalid register")
                if type(b) == "Reg" then b := Regs[b.v+1]
                Regs[a.v+1] := b
            }
            2 : { # push: 2 a push <a> onto the stack
                push(Stack,getVal(IP+:=1))
            }
            3 : { # pop: 3 a remove the top element from the stack and write it into <a>; empty stack = error
                if *Stack = 0 then stop("Empty Stack Error")
                v := pop(Stack)
                a := getVal(IP+:=1)
                if type(a) == "Reg" then Regs[a.v+1] := v
                else Mem[a+1] := v
            }
            4: { #

            }
        }

    }



end

procedure unpack()
    v := ord(move(1))           # Low byte
    v +:=  256 * ord(move(1))   # High byte
    return v
end
procedure pack(n)
    s := char(n % 256)          # Low byte
    s ||:= char(n/256)
    return s
end

procedure getVal(addr)
    /addr := IP
    v := Mem[addr]
    if v < 32768 then return v
    if v > 32776 then stop("Invalid number")
    return Reg(v - 32768) # Return a register value
end



procedure Init()
    Mem := list(32768)
    Regs := list(8)

    every i := 1 to 8 do
        Regs[i] := Reg(0)

    Stack := list()
    SP := 0
    IP := 0
    CC := 0
    opFuncs := [

    ]
end
